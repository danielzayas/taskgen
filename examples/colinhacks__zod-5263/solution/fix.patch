diff --git a/packages/zod/src/v4/classic/schemas.ts b/packages/zod/src/v4/classic/schemas.ts
index 6130b1f5..e3a50f3d 100644
--- a/packages/zod/src/v4/classic/schemas.ts
+++ b/packages/zod/src/v4/classic/schemas.ts
@@ -146,16 +146,14 @@ export const ZodType: core.$constructor<ZodType> = /*@__PURE__*/ core.$construct
   // base methods
   inst.check = (...checks) => {
     return inst.clone(
-      {
-        ...def,
+      util.mergeDefs(def, {
         checks: [
           ...(def.checks ?? []),
           ...checks.map((ch) =>
             typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch
           ),
         ],
-      }
-      // { parent: true }
+      })
     );
   };
   inst.clone = (def, params) => core.clone(inst, def, params);
@@ -1196,7 +1194,10 @@ export const ZodObject: core.$constructor<ZodObject> = /*@__PURE__*/ core.$const
   core.$ZodObjectJIT.init(inst, def);
   ZodType.init(inst, def);

-  util.defineLazy(inst, "shape", () => def.shape);
+  util.defineLazy(inst, "shape", () => {
+    return def.shape;
+  });
+
   inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)) as any;
   inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall as any as core.$ZodType }) as any;
   inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
@@ -1223,10 +1224,7 @@ export function object<T extends core.$ZodLooseShape = Partial<Record<never, cor
 ): ZodObject<util.Writeable<T>, core.$strip> {
   const def: core.$ZodObjectDef = {
     type: "object",
-    get shape() {
-      util.assignProp(this, "shape", shape ? util.objectClone(shape) : {});
-      return this.shape;
-    },
+    shape: shape!,
     ...util.normalizeParams(params),
   };
   return new ZodObject(def) as any;
@@ -1240,10 +1238,7 @@ export function strictObject<T extends core.$ZodLooseShape>(
 ): ZodObject<T, core.$strict> {
   return new ZodObject({
     type: "object",
-    get shape() {
-      util.assignProp(this, "shape", util.objectClone(shape));
-      return this.shape;
-    },
+    shape,
     catchall: never(),
     ...util.normalizeParams(params),
   }) as any;
@@ -1257,10 +1252,7 @@ export function looseObject<T extends core.$ZodLooseShape>(
 ): ZodObject<T, core.$loose> {
   return new ZodObject({
     type: "object",
-    get shape() {
-      util.assignProp(this, "shape", util.objectClone(shape));
-      return this.shape;
-    },
+    shape,
     catchall: unknown(),
     ...util.normalizeParams(params),
   }) as any;
diff --git a/packages/zod/src/v4/core/schemas.ts b/packages/zod/src/v4/core/schemas.ts
index 98aa588b..55cbfc50 100644
--- a/packages/zod/src/v4/core/schemas.ts
+++ b/packages/zod/src/v4/core/schemas.ts
@@ -1739,7 +1739,7 @@ export interface $ZodObjectDef<Shape extends $ZodShape = $ZodShape> extends $Zod

 export interface $ZodObjectInternals<
   /** @ts-ignore Cast variance */
-  out Shape extends Readonly<$ZodShape> = Readonly<$ZodShape>,
+  out Shape extends $ZodShape = $ZodShape,
   out Config extends $ZodObjectConfig = $ZodObjectConfig,
 > extends _$ZodTypeInternals {
   def: $ZodObjectDef<Shape>;
@@ -1825,6 +1825,21 @@ function handleCatchall(
 export const $ZodObject: core.$constructor<$ZodObject> = /*@__PURE__*/ core.$constructor("$ZodObject", (inst, def) => {
   // requires cast because technically $ZodObject doesn't extend
   $ZodType.init(inst, def);
+  // const sh = def.shape;
+  const desc = Object.getOwnPropertyDescriptor(def, "shape");
+  if (!desc!.get) {
+    const sh = def.shape;
+    Object.defineProperty(def, "shape", {
+      get: () => {
+        const newSh = { ...sh };
+        Object.defineProperty(def, "shape", {
+          value: newSh,
+        });
+
+        return newSh;
+      },
+    });
+  }

   const _normalized = util.cached(() => normalizeDef(def));

@@ -1853,7 +1868,6 @@ export const $ZodObject: core.$constructor<$ZodObject> = /*@__PURE__*/ core.$con
       payload.issues.push({
         expected: "object",
         code: "invalid_type",
-
         input,
         inst,
       });
diff --git a/packages/zod/src/v4/mini/schemas.ts b/packages/zod/src/v4/mini/schemas.ts
index 8dcd73aa..b5f065bf 100644
--- a/packages/zod/src/v4/mini/schemas.ts
+++ b/packages/zod/src/v4/mini/schemas.ts
@@ -769,10 +769,7 @@ export function object<T extends core.$ZodLooseShape = Record<never, SomeType>>(
 ): ZodMiniObject<T, core.$strip> {
   const def: core.$ZodObjectDef = {
     type: "object",
-    get shape() {
-      util.assignProp(this, "shape", { ...shape });
-      return this.shape;
-    },
+    shape: shape!,
     ...util.normalizeParams(params),
   };
   return new ZodMiniObject(def) as any;
@@ -785,11 +782,7 @@ export function strictObject<T extends core.$ZodLooseShape>(
 ): ZodMiniObject<T, core.$strict> {
   return new ZodMiniObject({
     type: "object",
-    // shape: shape as core.$ZodLooseShape,
-    get shape() {
-      util.assignProp(this, "shape", { ...shape });
-      return this.shape;
-    },
+    shape,
     catchall: never(),
     ...util.normalizeParams(params),
   }) as any;
@@ -802,14 +795,7 @@ export function looseObject<T extends core.$ZodLooseShape>(
 ): ZodMiniObject<T, core.$loose> {
   return new ZodMiniObject({
     type: "object",
-    // shape: shape as core.$ZodLooseShape,
-    get shape() {
-      util.assignProp(this, "shape", { ...shape });
-      return this.shape;
-    },
-    // get optional() {
-    //   return util.optionalKeys(shape);
-    // },
+    shape,
     catchall: unknown(),
     ...util.normalizeParams(params),
   }) as any;
diff --git a/play.ts b/play.ts
index 17d4f70e..25ffd69f 100644
--- a/play.ts
+++ b/play.ts
@@ -1,5 +1,52 @@
-const test = () => 1;
+import * as z from "zod";

-test.something = () => 2;
+z;

-test.something;
+// export const LinesSchema = <T extends z.ZodType<unknown, any>>(schema: T) =>
+//   z
+//     .string()
+//     .transform((input) => input.trim().split("\n"))
+//     .pipe(z.array(schema));
+
+const AType = z.object({
+  type: z.literal("a"),
+  name: z.string(),
+});
+
+const BType = z.object({
+  type: z.literal("b"),
+  name: z.string(),
+});
+
+const CType = z.object({
+  type: z.literal("c"),
+  name: z.string(),
+});
+
+const Schema = z.object({
+  type: z.literal("special").meta({ description: "Type" }),
+  config: z.object({
+    title: z.string().meta({ description: "Title" }),
+    get elements() {
+      return z.array(z.discriminatedUnion("type", [AType, BType, CType])).meta({
+        id: "SpecialElements",
+        title: "SpecialElements",
+        description: "Array of elements",
+      });
+    },
+  }),
+});
+
+console.log(
+  Schema.parse({
+    type: "special",
+    config: {
+      title: "Special",
+      elements: [
+        { type: "a", name: "John" },
+        { type: "b", name: "Jane" },
+        { type: "c", name: "Jim" },
+      ],
+    },
+  })
+);
