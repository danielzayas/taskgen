diff --git a/README.md b/README.md
index 6f14c29..e9d886e 100644
--- a/README.md
+++ b/README.md
@@ -87,6 +87,7 @@
     - [ðŸ”¥ Custom fetch](#-custom-fetch)
       - [ðŸ”¥ Using with Tauri](#-using-with-tauri)
       - [ðŸ”¥ Using with SvelteKit](#-using-with-sveltekit-)
+  - [ðŸ”¥ HTTP2](#-http2)
   - [Semver](#semver)
   - [Promises](#promises)
   - [TypeScript](#typescript)
@@ -1702,6 +1703,34 @@ export async function load({ fetch }) {
 }
 ```

+## ðŸ”¥ HTTP2
+
+In version `1.13.0`, experimental `HTTP2` support was added to the `http` adapter.
+The `httpVersion` option is now available to select the protocol version used.
+Additional native options for the internal `session.request()` call can be passed via the `http2Options` config.
+This config also includes the custom `sessionTimeout` parameter, which defaults to `1000ms`.
+
+```js
+const form = new FormData();
+
+    form.append('foo', '123');
+
+    const {data, headers, status} = await axios.post('https://httpbin.org/post', form, {
+      httpVersion: 2,
+      http2Options: {
+        // rejectUnauthorized: false,
+        // sessionTimeout: 1000
+      },
+      onUploadProgress(e) {
+        console.log('upload progress', e);
+      },
+      onDownloadProgress(e) {
+        console.log('download progress', e);
+      },
+      responseType: 'arraybuffer'
+    });
+```
+
 ## Semver

 Since Axios has reached a `v.1.0.0` we will fully embrace semver as per the spec [here](https://semver.org/)
diff --git a/index.d.cts b/index.d.cts
index 971a644..e3a06a3 100644
--- a/index.d.cts
+++ b/index.d.cts
@@ -436,6 +436,10 @@ declare namespace axios {
         ((hostname: string, options: object) => Promise<[address: LookupAddressEntry | LookupAddressEntry[], family?: AddressFamily] | LookupAddress>);
     withXSRFToken?: boolean | ((config: InternalAxiosRequestConfig) => boolean | undefined);
     fetchOptions?: Omit<RequestInit, 'body' | 'headers' | 'method' | 'signal'> | Record<string, any>;
+    httpVersion?: 1 | 2;
+    http2Options?: Record<string, any> & {
+      sessionTimeout?: number;
+    };
   }

   // Alias
diff --git a/index.d.ts b/index.d.ts
index 554140e..a97882a 100644
--- a/index.d.ts
+++ b/index.d.ts
@@ -369,6 +369,10 @@ export interface AxiosRequestConfig<D = any> {
   withXSRFToken?: boolean | ((config: InternalAxiosRequestConfig) => boolean | undefined);
   parseReviver?: (this: any, key: string, value: any) => any;
   fetchOptions?: Omit<RequestInit, 'body' | 'headers' | 'method' | 'signal'> | Record<string, any>;
+  httpVersion?: 1 | 2;
+  http2Options?: Record<string, any> & {
+    sessionTimeout?: number;
+  };
 }

 // Alias
diff --git a/lib/adapters/http.js b/lib/adapters/http.js
index a3489b2..ea69ff2 100755
--- a/lib/adapters/http.js
+++ b/lib/adapters/http.js
@@ -1,5 +1,4 @@
-'use strict';
-
+import { connect, constants } from 'http2';
 import utils from './../utils.js';
 import settle from './../core/settle.js';
 import buildFullPath from '../core/buildFullPath.js';
@@ -37,6 +36,13 @@ const brotliOptions = {
   finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
 }

+const {
+  HTTP2_HEADER_SCHEME,
+  HTTP2_HEADER_METHOD,
+  HTTP2_HEADER_PATH,
+  HTTP2_HEADER_STATUS
+} = constants;
+
 const isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);

 const {http: httpFollow, https: httpsFollow} = followRedirects;
@@ -56,6 +62,66 @@ const flushOnFinish = (stream, [throttled, flush]) => {
   return throttled;
 }

+class Http2Sessions {
+  constructor() {
+    this.sessions = Object.create(null);
+  }
+
+  getSession(authority, options) {
+    options = Object.assign({
+      sessionTimeout: 1000
+    }, options);
+
+    let authoritySessions;
+
+    if ((authoritySessions = this.sessions[authority])) {
+      let len = authoritySessions.length;
+
+      for (let i = 0; i < len; i++) {
+        const [sessionHandle, sessionOptions] = authoritySessions[i];
+        if (!sessionHandle.destroyed && !sessionHandle.closed && util.isDeepStrictEqual(sessionOptions, options)) {
+          return sessionHandle;
+        }
+      }
+    }
+
+    const session = connect(authority, options);
+
+    session.once('close', () => {
+      let entries = authoritySessions, len = entries.length, i = len;
+
+      while (i--) {
+        if (entries[i][0] === session) {
+          entries.splice(i, 1);
+          if (len === 1) {
+            delete this.sessions[authority];
+            return;
+          }
+        }
+      }
+    });
+
+    Http2Sessions.setTimeout(session, options.sessionTimeout);
+
+    let entries = this.sessions[authority], entry = [
+      session,
+      options
+    ];
+
+    entries ? this.sessions[authority].push(entry) : authoritySessions =  this.sessions[authority] = [entry];
+
+    return session;
+  }
+
+  static setTimeout(session, timeout = 1000) {
+    session && session.setTimeout(timeout, () => {
+      session.close();
+    });
+  }
+}
+
+const http2Sessions = new Http2Sessions();
+

 /**
  * If the proxy or config beforeRedirects functions are defined, call them with the options
@@ -168,16 +234,66 @@ const resolveFamily = ({address, family}) => {

 const buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});

+const http2Transport = {
+  request(options, cb) {
+      const authority = options.protocol + '//' + options.hostname + ':' + (options.port || 80);
+
+      const {http2Options, headers} = options;
+
+      const session = http2Sessions.getSession(authority, http2Options);
+
+      const http2Headers = {
+        [HTTP2_HEADER_SCHEME]: options.protocol.replace(':', ''),
+        [HTTP2_HEADER_METHOD]: options.method,
+        [HTTP2_HEADER_PATH]: options.path,
+      }
+
+      utils.forEach(headers, (header, name) => {
+        name.charAt(0) !== ':' && (http2Headers[name] = header);
+      });
+
+      const req = session.request(http2Headers);
+
+      req.once('response', (responseHeaders) => {
+        const response = req; //duplex
+
+        responseHeaders = Object.assign({}, responseHeaders);
+
+        const status = responseHeaders[HTTP2_HEADER_STATUS];
+
+        delete responseHeaders[HTTP2_HEADER_STATUS];
+
+        response.headers = responseHeaders;
+
+        response.statusCode = +status;
+
+        cb(response);
+      })
+
+      return req;
+  }
+}
+
 /*eslint consistent-return:0*/
 export default isHttpAdapterSupported && function httpAdapter(config) {
   return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
-    let {data, lookup, family} = config;
+    let {data, lookup, family, httpVersion = 1, http2Options} = config;
     const {responseType, responseEncoding} = config;
     const method = config.method.toUpperCase();
     let isDone;
     let rejected = false;
     let req;

+    httpVersion = Number(httpVersion);
+    if (Number.isNaN(httpVersion)) {
+      throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
+    }
+    if (httpVersion !== 1 && httpVersion !== 2) {
+      throw TypeError(`Unsupported protocol version '${httpVersion}'`);
+    }
+
+    const isHttp2 = httpVersion === 2;
+
     if (lookup) {
       const _lookup = callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);
       // hotfix to support opt.all option which is required for node 20.x
@@ -194,8 +310,17 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
       }
     }

-    // temporary internal emitter until the AxiosRequest class will be implemented
-    const emitter = new EventEmitter();
+    const abortEmitter = new EventEmitter();
+
+    function abort(reason) {
+      try {
+        abortEmitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
+      } catch(err) {
+        console.warn('emit error', err);
+      }
+    }
+
+    abortEmitter.once('abort', reject);

     const onFinished = () => {
       if (config.cancelToken) {
@@ -206,29 +331,40 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
         config.signal.removeEventListener('abort', abort);
       }

-      emitter.removeAllListeners();
+      abortEmitter.removeAllListeners();
     }

-    onDone((value, isRejected) => {
+    if (config.cancelToken || config.signal) {
+      config.cancelToken && config.cancelToken.subscribe(abort);
+      if (config.signal) {
+        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
+      }
+    }
+
+    onDone((response, isRejected) => {
       isDone = true;
+
       if (isRejected) {
         rejected = true;
         onFinished();
+        return;
+      }
+
+      const {data} = response;
+
+      if (data instanceof stream.Readable || data instanceof stream.Duplex) {
+        const offListeners = stream.finished(data, () => {
+          offListeners();
+          onFinished();
+        });
+      } else {
+        onFinished();
       }
     });

-    function abort(reason) {
-      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
-    }

-    emitter.once('abort', reject);

-    if (config.cancelToken || config.signal) {
-      config.cancelToken && config.cancelToken.subscribe(abort);
-      if (config.signal) {
-        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
-      }
-    }
+

     // Parse url
     const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
@@ -436,7 +572,8 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
       protocol,
       family,
       beforeRedirect: dispatchBeforeRedirect,
-      beforeRedirects: {}
+      beforeRedirects: {},
+      http2Options
     };

     // cacheable-lookup integration hotfix
@@ -453,18 +590,23 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
     let transport;
     const isHttpsRequest = isHttps.test(options.protocol);
     options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
-    if (config.transport) {
-      transport = config.transport;
-    } else if (config.maxRedirects === 0) {
-      transport = isHttpsRequest ? https : http;
+
+    if (isHttp2) {
+       transport = http2Transport;
     } else {
-      if (config.maxRedirects) {
-        options.maxRedirects = config.maxRedirects;
-      }
-      if (config.beforeRedirect) {
-        options.beforeRedirects.config = config.beforeRedirect;
+      if (config.transport) {
+        transport = config.transport;
+      } else if (config.maxRedirects === 0) {
+        transport = isHttpsRequest ? https : http;
+      } else {
+        if (config.maxRedirects) {
+          options.maxRedirects = config.maxRedirects;
+        }
+        if (config.beforeRedirect) {
+          options.beforeRedirects.config = config.beforeRedirect;
+        }
+        transport = isHttpsRequest ? httpsFollow : httpFollow;
       }
-      transport = isHttpsRequest ? httpsFollow : httpFollow;
     }

     if (config.maxBodyLength > -1) {
@@ -484,7 +626,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {

       const streams = [res];

-      const responseLength = +res.headers['content-length'];
+      const responseLength = utils.toFiniteNumber(res.headers['content-length']);

       if (onDownloadProgress || maxDownloadRate) {
         const transformStream = new AxiosTransformStream({
@@ -547,10 +689,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {

       responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];

-      const offListeners = stream.finished(responseStream, () => {
-        offListeners();
-        onFinished();
-      });
+

       const response = {
         status: res.statusCode,
@@ -562,7 +701,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {

       if (responseType === 'stream') {
         response.data = responseStream;
-        settle(resolve, reject, response);
+        settle(resolve, abort, response);
       } else {
         const responseBuffer = [];
         let totalResponseBytes = 0;
@@ -576,7 +715,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
             // stream.destroy() emit aborted event before calling reject() on Node.js v16
             rejected = true;
             responseStream.destroy();
-            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
+            abort(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
               AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
           }
         });
@@ -618,7 +757,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
         });
       }

-      emitter.once('abort', err => {
+      abortEmitter.once('abort', err => {
         if (!responseStream.destroyed) {
           responseStream.emit('error', err);
           responseStream.destroy();
@@ -626,9 +765,12 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
       });
     });

-    emitter.once('abort', err => {
-      reject(err);
-      req.destroy(err);
+    abortEmitter.once('abort', err => {
+      if (req.close) {
+        req.close();
+      } else {
+        req.destroy(err);
+      }
     });

     // Handle errors
@@ -650,7 +792,7 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
       const timeout = parseInt(config.timeout, 10);

       if (Number.isNaN(timeout)) {
-        reject(new AxiosError(
+        abort(new AxiosError(
           'error trying to parse `config.timeout` to int',
           AxiosError.ERR_BAD_OPTION_VALUE,
           config,
@@ -672,13 +814,12 @@ export default isHttpAdapterSupported && function httpAdapter(config) {
         if (config.timeoutErrorMessage) {
           timeoutErrorMessage = config.timeoutErrorMessage;
         }
-        reject(new AxiosError(
+        abort(new AxiosError(
           timeoutErrorMessage,
           transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
           config,
           req
         ));
-        abort();
       });
     }

@@ -705,7 +846,8 @@ export default isHttpAdapterSupported && function httpAdapter(config) {

       data.pipe(req);
     } else {
-      req.end(data);
+      data && req.write(data);
+      req.end();
     }
   });
 }
diff --git a/package-lock.json b/package-lock.json
index b90391b..37b4c75 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -66,6 +66,7 @@
         "rollup-plugin-auto-external": "^2.0.0",
         "rollup-plugin-bundle-size": "^1.0.3",
         "rollup-plugin-terser": "^7.0.2",
+        "selfsigned": "^3.0.1",
         "sinon": "^4.5.0",
         "stream-throttle": "^0.1.3",
         "string-replace-async": "^3.0.2",
@@ -17909,6 +17910,16 @@
         }
       }
     },
+    "node_modules/node-forge": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-1.3.1.tgz",
+      "integrity": "sha512-dPEtOeMvF9VMcYV/1Wb8CPoVAXtp6MKMlcbAt4ddqmGqUJ6fQZFXkNZNkNlfevtNkGtaSoXf/vNNNSvgrdXwtA==",
+      "dev": true,
+      "license": "(BSD-3-Clause OR GPL-2.0)",
+      "engines": {
+        "node": ">= 6.13.0"
+      }
+    },
     "node_modules/node-gyp": {
       "version": "11.4.2",
       "resolved": "https://registry.npmjs.org/node-gyp/-/node-gyp-11.4.2.tgz",
@@ -22316,6 +22327,19 @@
         "seek-table": "bin/seek-bzip-table"
       }
     },
+    "node_modules/selfsigned": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/selfsigned/-/selfsigned-3.0.1.tgz",
+      "integrity": "sha512-6U6w6kSLrM9Zxo0D7mC7QdGS6ZZytMWBnj/vhF9p+dAHx6CwGezuRcO4VclTbrrI7mg7SD6zNiqXUuBHOVopNQ==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "node-forge": "^1"
+      },
+      "engines": {
+        "node": ">=10"
+      }
+    },
     "node_modules/semver": {
       "version": "7.3.8",
       "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
@@ -40788,6 +40812,12 @@
         "whatwg-url": "^5.0.0"
       }
     },
+    "node-forge": {
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/node-forge/-/node-forge-1.3.1.tgz",
+      "integrity": "sha512-dPEtOeMvF9VMcYV/1Wb8CPoVAXtp6MKMlcbAt4ddqmGqUJ6fQZFXkNZNkNlfevtNkGtaSoXf/vNNNSvgrdXwtA==",
+      "dev": true
+    },
     "node-gyp": {
       "version": "11.4.2",
       "resolved": "https://registry.npmjs.org/node-gyp/-/node-gyp-11.4.2.tgz",
@@ -44115,6 +44145,15 @@
         "commander": "^2.8.1"
       }
     },
+    "selfsigned": {
+      "version": "3.0.1",
+      "resolved": "https://registry.npmjs.org/selfsigned/-/selfsigned-3.0.1.tgz",
+      "integrity": "sha512-6U6w6kSLrM9Zxo0D7mC7QdGS6ZZytMWBnj/vhF9p+dAHx6CwGezuRcO4VclTbrrI7mg7SD6zNiqXUuBHOVopNQ==",
+      "dev": true,
+      "requires": {
+        "node-forge": "^1"
+      }
+    },
     "semver": {
       "version": "7.3.8",
       "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.8.tgz",
diff --git a/package.json b/package.json
index 98e0749..b04de5a 100644
--- a/package.json
+++ b/package.json
@@ -146,6 +146,7 @@
     "rollup-plugin-auto-external": "^2.0.0",
     "rollup-plugin-bundle-size": "^1.0.3",
     "rollup-plugin-terser": "^7.0.2",
+    "selfsigned": "^3.0.1",
     "sinon": "^4.5.0",
     "stream-throttle": "^0.1.3",
     "string-replace-async": "^3.0.2",
